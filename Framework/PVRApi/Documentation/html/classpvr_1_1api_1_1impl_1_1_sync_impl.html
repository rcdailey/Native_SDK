<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.4"/>
<title>PVRApi: pvr::api::impl::SyncImpl Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%" border="none"/></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRApi</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="namespacepvr_1_1api.html">api</a></li><li class="navelem"><a class="el" href="namespacepvr_1_1api_1_1impl.html">impl</a></li><li class="navelem"><a class="el" href="classpvr_1_1api_1_1impl_1_1_sync_impl.html">SyncImpl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpvr_1_1api_1_1impl_1_1_sync_impl-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::api::impl::SyncImpl Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The Sync object can be used both as an API command, or to be directly queried by the application. Each time the CommandBuffer is submitted, an underlying sync object is added to the list. If the MaxSize is reached, the first sync object to be submitted is discarder. The user normally queries/uses the syncs last-to-first with an index. This technique makes it trivial to use frame-lag techniques, like double/triple buffering. Each Sync starts in a non-signaled state, and becomes Signaled as soon as the GPU actually executes it previous command. All of the functions work on a last-to-first indexing - passing 0 refers to the last command buffer submission, and from there backwards in time, until <a class="el" href="classpvr_1_1api_1_1impl_1_1_sync_impl.html#a5f5bc6e83f3a4a4aeade450c7e32d117" title="Get the maximum number of syncs that will be created. Each time the command buffer that created this ...">getMaxSize()</a> - 1, which is the earliest sync point used. Use: Get a sync object with insertFenceSync(). 2) Use <a class="el" href="classpvr_1_1api_1_1impl_1_1_sync_impl.html#ac0305a5a59f8e99fbbad25d64f672331" title="Call this function to wait on the sync object (i.e. wait for it to become Signalled, meaning that any commands preceding it are complete) ">clientWait()</a> to CPU-block until the Sync becomes Signaled. 3) Use <a class="el" href="classpvr_1_1api_1_1impl_1_1_sync_impl.html#a7687ac2841e2bd745e17235ecdb6597b" title="Call this function to test if a Sync is signalled, without blocking for it. Each call to &quot;submit&quot; on ...">isSignaled()</a> to query if the Sync is Signaled, without blocking. 4) Use commandBuffer.serverSync() to force the implementation to wait for the specified sync object before proceeding.  
 <a href="classpvr_1_1api_1_1impl_1_1_sync_impl.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac0305a5a59f8e99fbbad25d64f672331"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpvr_1_1api_1_1impl_1_1_sync_wait_result.html#ab6a55d9bcdc689af75bace5abfc9fb63">SyncWaitResult::Enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_sync_impl.html#ac0305a5a59f8e99fbbad25d64f672331">clientWait</a> (uint32 which, uint64 <a class="el" href="_api_gles3_8h.html#ad29bb0d8468b264a4e3d9204366cfaab">timeout</a>=0)</td></tr>
<tr class="memdesc:ac0305a5a59f8e99fbbad25d64f672331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function to wait on the sync object (i.e. wait for it to become Signalled, meaning that any commands preceding it are complete)  <a href="#ac0305a5a59f8e99fbbad25d64f672331">More...</a><br/></td></tr>
<tr class="separator:ac0305a5a59f8e99fbbad25d64f672331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c632a7e814ad2fd45b11f2a9c43895"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_sync_impl.html#a26c632a7e814ad2fd45b11f2a9c43895">discardLast</a> (int32 howMany=1)</td></tr>
<tr class="memdesc:a26c632a7e814ad2fd45b11f2a9c43895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually discards the last howMany sync points. Specialised use only.  <a href="#a26c632a7e814ad2fd45b11f2a9c43895">More...</a><br/></td></tr>
<tr class="separator:a26c632a7e814ad2fd45b11f2a9c43895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5bc6e83f3a4a4aeade450c7e32d117"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_sync_impl.html#a5f5bc6e83f3a4a4aeade450c7e32d117">getMaxSize</a> ()</td></tr>
<tr class="memdesc:a5f5bc6e83f3a4a4aeade450c7e32d117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum number of syncs that will be created. Each time the command buffer that created this sync object (with the insertFenceSync call) is submitted, another sync is created. When MaxSize is reached, the first sync to be created is discarded.  <a href="#a5f5bc6e83f3a4a4aeade450c7e32d117">More...</a><br/></td></tr>
<tr class="separator:a5f5bc6e83f3a4a4aeade450c7e32d117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7687ac2841e2bd745e17235ecdb6597b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_sync_impl.html#a7687ac2841e2bd745e17235ecdb6597b">isSignaled</a> (uint32 which)</td></tr>
<tr class="memdesc:a7687ac2841e2bd745e17235ecdb6597b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function to test if a Sync is signalled, without blocking for it. Each call to "submit" on the command buffer that created this sync, will push a new sync point to the front of this queue.  <a href="#a7687ac2841e2bd745e17235ecdb6597b">More...</a><br/></td></tr>
<tr class="separator:a7687ac2841e2bd745e17235ecdb6597b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e57d8c812a42a51419643544fdd34c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_sync_impl.html#a49e57d8c812a42a51419643544fdd34c">setMaxSize</a> (uint32 maxSize)</td></tr>
<tr class="memdesc:a49e57d8c812a42a51419643544fdd34c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of syncs that will be created. Each time the command buffer that created this sync object (with the insertFenceSync call) is submitted, another sync is created. When MaxSize is reached, the first sync to be created is discarded.  <a href="#a49e57d8c812a42a51419643544fdd34c">More...</a><br/></td></tr>
<tr class="separator:a49e57d8c812a42a51419643544fdd34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Sync object can be used both as an API command, or to be directly queried by the application. Each time the CommandBuffer is submitted, an underlying sync object is added to the list. If the MaxSize is reached, the first sync object to be submitted is discarder. The user normally queries/uses the syncs last-to-first with an index. This technique makes it trivial to use frame-lag techniques, like double/triple buffering. Each Sync starts in a non-signaled state, and becomes Signaled as soon as the GPU actually executes it previous command. All of the functions work on a last-to-first indexing - passing 0 refers to the last command buffer submission, and from there backwards in time, until <a class="el" href="classpvr_1_1api_1_1impl_1_1_sync_impl.html#a5f5bc6e83f3a4a4aeade450c7e32d117" title="Get the maximum number of syncs that will be created. Each time the command buffer that created this ...">getMaxSize()</a> - 1, which is the earliest sync point used. Use: Get a sync object with insertFenceSync(). 2) Use <a class="el" href="classpvr_1_1api_1_1impl_1_1_sync_impl.html#ac0305a5a59f8e99fbbad25d64f672331" title="Call this function to wait on the sync object (i.e. wait for it to become Signalled, meaning that any commands preceding it are complete) ">clientWait()</a> to CPU-block until the Sync becomes Signaled. 3) Use <a class="el" href="classpvr_1_1api_1_1impl_1_1_sync_impl.html#a7687ac2841e2bd745e17235ecdb6597b" title="Call this function to test if a Sync is signalled, without blocking for it. Each call to &quot;submit&quot; on ...">isSignaled()</a> to query if the Sync is Signaled, without blocking. 4) Use commandBuffer.serverSync() to force the implementation to wait for the specified sync object before proceeding. </p>
<hr/>
 </div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac0305a5a59f8e99fbbad25d64f672331"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpvr_1_1api_1_1impl_1_1_sync_wait_result.html#ab6a55d9bcdc689af75bace5abfc9fb63">SyncWaitResult::Enum</a> pvr::api::impl::SyncImpl::clientWait </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this function to wait on the sync object (i.e. wait for it to become Signalled, meaning that any commands preceding it are complete) </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Optional: Provide a timeout. If 0 is passed, the wait is infinite. </td></tr>
    <tr><td class="paramname">which</td><td>The fence sync to wait on (0 is the latest, maxSize is the earliest). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>* SyncResult::Ok if the Sync was either already signaled or became signaled within the timeout (the preceding commands have finished) SyncResult::CommandBufferNotSubmitted if the commandBuffer that would generat the Sync has not yet been submitted, hence the sync will never be signalled (so waiting on it would probably result in a deadlock). SyncResult::TimeoutExpired, if the Sync was NOT signalled, but the timeout expired. SyncResult::Failed, if the implementation failed to wait (for example, the sync was already destroyed) </dd></dl>

</div>
</div>
<a class="anchor" id="a26c632a7e814ad2fd45b11f2a9c43895"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::SyncImpl::discardLast </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>howMany</em> = <code>1</code>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manually discards the last howMany sync points. Specialised use only. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">howMany</td><td>The number of sync points to discard. Non positive numbers have no effect. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5f5bc6e83f3a4a4aeade450c7e32d117"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::api::impl::SyncImpl::getMaxSize </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the maximum number of syncs that will be created. Each time the command buffer that created this sync object (with the insertFenceSync call) is submitted, another sync is created. When MaxSize is reached, the first sync to be created is discarded. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>The maximum number of sync points that this object represents. </dd></dl>

</div>
</div>
<a class="anchor" id="a7687ac2841e2bd745e17235ecdb6597b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::api::impl::SyncImpl::isSignaled </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>which</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this function to test if a Sync is signalled, without blocking for it. Each call to "submit" on the command buffer that created this sync, will push a new sync point to the front of this queue. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>The ordinal, newest-to-oldest, of the sync point to query (0=last submit, 1=previous frame etc.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the Sync is signaled (hence its previous commands are complete), false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a49e57d8c812a42a51419643544fdd34c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::SyncImpl::setMaxSize </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>maxSize</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum number of syncs that will be created. Each time the command buffer that created this sync object (with the insertFenceSync call) is submitted, another sync is created. When MaxSize is reached, the first sync to be created is discarded. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxSize</td><td>The maximum number of sync points that this object represents will be set to this number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/dev/buildxl/buildroot/sdk/branch/Framework/PVRApi/<a class="el" href="_api_commands_8h_source.html">ApiCommands.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
