<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.4"/>
<title>PVRApi: pvr::api::impl::CommandBufferBaseImpl Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%" border="none"/></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRApi</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="namespacepvr_1_1api.html">api</a></li><li class="navelem"><a class="el" href="namespacepvr_1_1api_1_1impl.html">impl</a></li><li class="navelem"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html">CommandBufferBaseImpl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::api::impl::CommandBufferBaseImpl Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains all the commands and states that need to be submitted to the gpu, including pipeline, texture, and samplers. Virtually everything that needs to happen on the GPU is submitted to the CommandBuffer. In debug builds (define DEBUG or define PVR_STORE_STACK_TRACE_WITH_API_COMMANDS), a limited stack trace is stored with each command so that if an error occurs, the site where the command was actually added to the command buffer can be determined.  
 <a href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for pvr::api::impl::CommandBufferBaseImpl:</div>
<div class="dyncontent">
<div class="center"><img src="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl__inherit__graph.png" border="0" usemap="#pvr_1_1api_1_1impl_1_1_command_buffer_base_impl_inherit__map" alt="Inheritance graph"/></div>
<map name="pvr_1_1api_1_1impl_1_1_command_buffer_base_impl_inherit__map" id="pvr_1_1api_1_1impl_1_1_command_buffer_base_impl_inherit__map">
<area shape="rect" id="node2" href="classpvr_1_1api_1_1impl_1_1_command_buffer_impl.html" title="Contains all the commands and states that need to be submitted to the gpu, including pipeline..." alt="" coords="5,104,224,131"/>
<area shape="rect" id="node3" href="classpvr_1_1api_1_1impl_1_1_secondary_command_buffer_impl.html" title="Contains all the commands and states that need to be submitted to the gpu, including pipeline..." alt="" coords="248,97,413,138"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2d9b06daf680e0dbc19a8f8c9dfc8dda"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a2d9b06daf680e0dbc19a8f8c9dfc8dda">~CommandBufferBaseImpl</a> ()</td></tr>
<tr class="memdesc:a2d9b06daf680e0dbc19a8f8c9dfc8dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. Frees all resources.  <a href="#a2d9b06daf680e0dbc19a8f8c9dfc8dda">More...</a><br/></td></tr>
<tr class="separator:a2d9b06daf680e0dbc19a8f8c9dfc8dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721f2afa698ea20a3a8f38ca5e571833"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a721f2afa698ea20a3a8f38ca5e571833">beginRecording</a> ()</td></tr>
<tr class="memdesc:a721f2afa698ea20a3a8f38ca5e571833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function before beginning to record commands.  <a href="#a721f2afa698ea20a3a8f38ca5e571833">More...</a><br/></td></tr>
<tr class="separator:a721f2afa698ea20a3a8f38ca5e571833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595b5ae58675dde002a875befecbf50d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a595b5ae58675dde002a875befecbf50d">bindDescriptorSets</a> (<a class="el" href="namespacepvr_1_1api_1_1_pipeline_binding_point.html#a321e31cba9cffb8c4fc858ac34ebec8f">PipelineBindingPoint::Enum</a> bindingPoint, const api::PipelineLayout &amp;pipelineLayout, const DescriptorSet &amp;set, uint32 dynamicOffset)</td></tr>
<tr class="memdesc:a595b5ae58675dde002a875befecbf50d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a single DescriptorSet.  <a href="#a595b5ae58675dde002a875befecbf50d">More...</a><br/></td></tr>
<tr class="separator:a595b5ae58675dde002a875befecbf50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ce38348ce724cf709cdd94dd1d521d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#af2ce38348ce724cf709cdd94dd1d521d">bindDescriptorSets</a> (<a class="el" href="namespacepvr_1_1api_1_1_pipeline_binding_point.html#a321e31cba9cffb8c4fc858ac34ebec8f">PipelineBindingPoint::Enum</a> bindingPoint, const api::PipelineLayout &amp;pipelineLayout, DescriptorSet *sets, uint32 *dynamicOffsets, uint32 <a class="el" href="_api_gles2_8h.html#a5b40aca7a9682963dd00a8f5aef0a901">count</a>)</td></tr>
<tr class="memdesc:af2ce38348ce724cf709cdd94dd1d521d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind multiple DescriptorSets.  <a href="#af2ce38348ce724cf709cdd94dd1d521d">More...</a><br/></td></tr>
<tr class="separator:af2ce38348ce724cf709cdd94dd1d521d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0b4abd6adbaa52e4dadfcd1fa0c3eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a8f0b4abd6adbaa52e4dadfcd1fa0c3eb">bindIndexBuffer</a> (const <a class="el" href="classpvr_1_1api_1_1_buffer.html">api::Buffer</a> &amp;<a class="el" href="_api_gles2_8h.html#a6c0f527f003707dfaca177b40f406ed9">buffer</a>, uint32 <a class="el" href="_api_gles2_8h.html#a6ed43c61a3fbf165f2eaf5f39282e908">offset</a>, IndexType::Enum indexType)</td></tr>
<tr class="memdesc:a8f0b4abd6adbaa52e4dadfcd1fa0c3eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind an index buffer for drawing.  <a href="#a8f0b4abd6adbaa52e4dadfcd1fa0c3eb">More...</a><br/></td></tr>
<tr class="separator:a8f0b4abd6adbaa52e4dadfcd1fa0c3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12099cfcd5202d7f4bd32a99775c2156"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a12099cfcd5202d7f4bd32a99775c2156">bindPipeline</a> (GraphicsPipeline &amp;pipeline)</td></tr>
<tr class="memdesc:a12099cfcd5202d7f4bd32a99775c2156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a graphics pipeline.  <a href="#a12099cfcd5202d7f4bd32a99775c2156">More...</a><br/></td></tr>
<tr class="separator:a12099cfcd5202d7f4bd32a99775c2156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908a1e8ff752979afdd0f7a1879f9ea1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a908a1e8ff752979afdd0f7a1879f9ea1">bindPipeline</a> (ParentableGraphicsPipeline &amp;pipeline)</td></tr>
<tr class="memdesc:a908a1e8ff752979afdd0f7a1879f9ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a parentable graphics pipeline.  <a href="#a908a1e8ff752979afdd0f7a1879f9ea1">More...</a><br/></td></tr>
<tr class="separator:a908a1e8ff752979afdd0f7a1879f9ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463fa2ed3ba1b1075b677ae6f1991e33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a463fa2ed3ba1b1075b677ae6f1991e33">bindPipeline</a> (ComputePipeline &amp;pipeline)</td></tr>
<tr class="memdesc:a463fa2ed3ba1b1075b677ae6f1991e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a compute pipeline.  <a href="#a463fa2ed3ba1b1075b677ae6f1991e33">More...</a><br/></td></tr>
<tr class="separator:a463fa2ed3ba1b1075b677ae6f1991e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ccdc490c34800343f488b60fe96625"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#ab9ccdc490c34800343f488b60fe96625">bindVertexBuffer</a> (const <a class="el" href="classpvr_1_1api_1_1_buffer.html">Buffer</a> &amp;<a class="el" href="_api_gles2_8h.html#a6c0f527f003707dfaca177b40f406ed9">buffer</a>, uint32 <a class="el" href="_api_gles2_8h.html#a6ed43c61a3fbf165f2eaf5f39282e908">offset</a>, uint16 bindingIndex)</td></tr>
<tr class="memdesc:ab9ccdc490c34800343f488b60fe96625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a Vertex <a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">Buffer</a> for drawing.  <a href="#ab9ccdc490c34800343f488b60fe96625">More...</a><br/></td></tr>
<tr class="separator:ab9ccdc490c34800343f488b60fe96625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92596393c46edc459b5da7e720fdd1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#ac92596393c46edc459b5da7e720fdd1b">bindVertexBuffer</a> (<a class="el" href="classpvr_1_1api_1_1_buffer.html">Buffer</a> const *<a class="el" href="_api_gles2_8h.html#acaf3212fc88caa23745613e709a3e869">buffers</a>, uint32 *offsets, uint16 numBuffers, uint16 startBinding, uint16 bindingCount)</td></tr>
<tr class="memdesc:ac92596393c46edc459b5da7e720fdd1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind an array of Vertex Buffers.  <a href="#ac92596393c46edc459b5da7e720fdd1b">More...</a><br/></td></tr>
<tr class="separator:ac92596393c46edc459b5da7e720fdd1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9a837a39fca41d008b56b6b7f46cf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a9e9a837a39fca41d008b56b6b7f46cf5">clear</a> ()</td></tr>
<tr class="memdesc:a9e9a837a39fca41d008b56b6b7f46cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the command queue. It is invalid to clear the command buffer while it is being recorded.  <a href="#a9e9a837a39fca41d008b56b6b7f46cf5">More...</a><br/></td></tr>
<tr class="separator:a9e9a837a39fca41d008b56b6b7f46cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0347f25ee9dc17043ba09fb2b4e9a220"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a0347f25ee9dc17043ba09fb2b4e9a220">clearColorAttachment</a> (pvr::uint32 attachmentCount, glm::vec4 const *clearColors, const pvr::Rectanglei *rects)</td></tr>
<tr class="memdesc:a0347f25ee9dc17043ba09fb2b4e9a220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear multiple attachments with separate clear colors and clear rectangle for each.  <a href="#a0347f25ee9dc17043ba09fb2b4e9a220">More...</a><br/></td></tr>
<tr class="separator:a0347f25ee9dc17043ba09fb2b4e9a220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ddd610781c061bdd9dfff7e8a25f02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a58ddd610781c061bdd9dfff7e8a25f02">clearColorAttachment</a> (pvr::uint32 attachmentCount, glm::vec4 clearColor, const pvr::Rectanglei rect)</td></tr>
<tr class="memdesc:a58ddd610781c061bdd9dfff7e8a25f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear multiple attachment with a single clear color and a single rectangle.  <a href="#a58ddd610781c061bdd9dfff7e8a25f02">More...</a><br/></td></tr>
<tr class="separator:a58ddd610781c061bdd9dfff7e8a25f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e96fd756b887c4e6e2a0439bf1d820e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a8e96fd756b887c4e6e2a0439bf1d820e">clearDepthAttachment</a> (const pvr::Rectanglei &amp;clearRect, float32 <a class="el" href="_api_gles3_8h.html#a2aa5ce5567a58e4da543ce468fb1711a">depth</a>=1.<a class="el" href="_api_gles2_8h.html#a0fdda94b8b7e64884690244028f455ba">f</a>)</td></tr>
<tr class="memdesc:a8e96fd756b887c4e6e2a0439bf1d820e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the depth attachment of an fbo.  <a href="#a8e96fd756b887c4e6e2a0439bf1d820e">More...</a><br/></td></tr>
<tr class="separator:a8e96fd756b887c4e6e2a0439bf1d820e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4698b949015f61ad7c76d5dc25bab248"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a4698b949015f61ad7c76d5dc25bab248">clearDepthStencilAttachment</a> (const pvr::Rectanglei &amp;clearRect, float32 <a class="el" href="_api_gles3_8h.html#a2aa5ce5567a58e4da543ce468fb1711a">depth</a>=1.<a class="el" href="_api_gles2_8h.html#a0fdda94b8b7e64884690244028f455ba">f</a>, pvr::int32 <a class="el" href="_api_gles3_8h.html#aecd18db993a66d833647945966799ca5">stencil</a>=0)</td></tr>
<tr class="memdesc:a4698b949015f61ad7c76d5dc25bab248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the depth stencil attachment.  <a href="#a4698b949015f61ad7c76d5dc25bab248">More...</a><br/></td></tr>
<tr class="separator:a4698b949015f61ad7c76d5dc25bab248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23d64521e8c24b3e78e90f899b2f57e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#af23d64521e8c24b3e78e90f899b2f57e">clearStencilAttachment</a> (const pvr::Rectanglei &amp;clearRect, pvr::int32 <a class="el" href="_api_gles3_8h.html#aecd18db993a66d833647945966799ca5">stencil</a>=0)</td></tr>
<tr class="memdesc:af23d64521e8c24b3e78e90f899b2f57e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the stencil attachment of an fbo.  <a href="#af23d64521e8c24b3e78e90f899b2f57e">More...</a><br/></td></tr>
<tr class="separator:af23d64521e8c24b3e78e90f899b2f57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a367ecb19a73d906164dd0d4903ca66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a5a367ecb19a73d906164dd0d4903ca66">dispatchCompute</a> (uint32 numGroupsX, uint32 numGroupsY=1, uint32 numGroupsZ=1)</td></tr>
<tr class="memdesc:a5a367ecb19a73d906164dd0d4903ca66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a ComputeShader execution using the ComputeShader that is in the currently bound ComputePipeline.  <a href="#a5a367ecb19a73d906164dd0d4903ca66">More...</a><br/></td></tr>
<tr class="separator:a5a367ecb19a73d906164dd0d4903ca66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af462cb102f76680063615bcebb726885"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#af462cb102f76680063615bcebb726885">drawArrays</a> (uint32 firstVertex, uint32 vertexCount, uint32 firstInstance=0, uint32 instanceCount=1)</td></tr>
<tr class="memdesc:af462cb102f76680063615bcebb726885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw command. Use the current state in the command buffer (pipelines, buffers, descriptor sets) to execute a drawing command. Does not use an IndexBuffer.  <a href="#af462cb102f76680063615bcebb726885">More...</a><br/></td></tr>
<tr class="separator:af462cb102f76680063615bcebb726885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32fc17d096f7064ac969958202e5ef4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a32fc17d096f7064ac969958202e5ef4c">drawIndexed</a> (uint32 firstIndex, uint32 indexCount, uint32 vertexOffset=0, uint32 firstInstance=0, uint32 instanceCount=1)</td></tr>
<tr class="memdesc:a32fc17d096f7064ac969958202e5ef4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw command. Use the current state in the command buffer (pipelines, buffers, descriptor sets) to execute a drawing command. Uses the currently bound IndexBuffer for indexes into the currently bound VBOs.  <a href="#a32fc17d096f7064ac969958202e5ef4c">More...</a><br/></td></tr>
<tr class="separator:a32fc17d096f7064ac969958202e5ef4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f955fe4db46fb3efd73a320a92a5ff9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a6f955fe4db46fb3efd73a320a92a5ff9">drawIndexedIndirect</a> (<a class="el" href="classpvr_1_1api_1_1_buffer.html">Buffer</a> &amp;<a class="el" href="_api_gles2_8h.html#a6c0f527f003707dfaca177b40f406ed9">buffer</a>)</td></tr>
<tr class="memdesc:a6f955fe4db46fb3efd73a320a92a5ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indirect Draw command. Use buffer to obtain the draw call parameters.  <a href="#a6f955fe4db46fb3efd73a320a92a5ff9">More...</a><br/></td></tr>
<tr class="separator:a6f955fe4db46fb3efd73a320a92a5ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1816c4245c3afdffe2e06cca36a707"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a1b1816c4245c3afdffe2e06cca36a707">drawIndirect</a> (<a class="el" href="classpvr_1_1api_1_1_buffer.html">Buffer</a> &amp;<a class="el" href="_api_gles2_8h.html#a6c0f527f003707dfaca177b40f406ed9">buffer</a>, pvr::uint32 <a class="el" href="_api_gles2_8h.html#a6ed43c61a3fbf165f2eaf5f39282e908">offset</a>, pvr::uint32 <a class="el" href="_api_gles2_8h.html#a5b40aca7a9682963dd00a8f5aef0a901">count</a>, pvr::uint32 <a class="el" href="_api_gles2_8h.html#adec60f1216ca1b900f8d776c5b6190e0">stride</a>)</td></tr>
<tr class="memdesc:a1b1816c4245c3afdffe2e06cca36a707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw indirect.  <a href="#a1b1816c4245c3afdffe2e06cca36a707">More...</a><br/></td></tr>
<tr class="separator:a1b1816c4245c3afdffe2e06cca36a707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698056509d1cbede4e8e830c4e0d0423"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a698056509d1cbede4e8e830c4e0d0423">endRecording</a> ()</td></tr>
<tr class="memdesc:a698056509d1cbede4e8e830c4e0d0423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function when you are done recording commands. BeginRecording must be called first.  <a href="#a698056509d1cbede4e8e830c4e0d0423">More...</a><br/></td></tr>
<tr class="separator:a698056509d1cbede4e8e830c4e0d0423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6095737c196cb06e52bd69e4aff9372a"><td class="memItemLeft" align="right" valign="top">GraphicsContext &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a6095737c196cb06e52bd69e4aff9372a">getContext</a> ()</td></tr>
<tr class="memdesc:a6095737c196cb06e52bd69e4aff9372a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the context used by this CommandBuffer.  <a href="#a6095737c196cb06e52bd69e4aff9372a">More...</a><br/></td></tr>
<tr class="separator:a6095737c196cb06e52bd69e4aff9372a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500ef1a3c200d246e4d36c5378e5e3a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr_1_1api.html#aed7be4927619057cc4c9f136198da2f5">Sync</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a500ef1a3c200d246e4d36c5378e5e3a1">insertFenceSync</a> ()</td></tr>
<tr class="memdesc:a500ef1a3c200d246e4d36c5378e5e3a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a synchronization object collection to the command stream and return its handle to the user. The user may then use the sync points for a configurable number of command buffer submition.  <a href="#a500ef1a3c200d246e4d36c5378e5e3a1">More...</a><br/></td></tr>
<tr class="separator:a500ef1a3c200d246e4d36c5378e5e3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285ae290613736990812f4ff4dcaf6d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a285ae290613736990812f4ff4dcaf6d7">isRecording</a> ()</td></tr>
<tr class="memdesc:a285ae290613736990812f4ff4dcaf6d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries if a command buffer is in the recording state.  <a href="#a285ae290613736990812f4ff4dcaf6d7">More...</a><br/></td></tr>
<tr class="separator:a285ae290613736990812f4ff4dcaf6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19fac5486f7a1bfebaffdcfdfbe05689"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a19fac5486f7a1bfebaffdcfdfbe05689">popPipeline</a> ()</td></tr>
<tr class="memdesc:a19fac5486f7a1bfebaffdcfdfbe05689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the previously pushed pipeline (See pushGraphicsPipeline)  <a href="#a19fac5486f7a1bfebaffdcfdfbe05689">More...</a><br/></td></tr>
<tr class="separator:a19fac5486f7a1bfebaffdcfdfbe05689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57ddf2a5c75e323537c94ceb24e65ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#ac57ddf2a5c75e323537c94ceb24e65ea">pushPipeline</a> ()</td></tr>
<tr class="memdesc:ac57ddf2a5c75e323537c94ceb24e65ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store which pipeline is currently bound, so that it can later be retrieved and bound with a popPipeline command.  <a href="#ac57ddf2a5c75e323537c94ceb24e65ea">More...</a><br/></td></tr>
<tr class="separator:ac57ddf2a5c75e323537c94ceb24e65ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cdc6182abdd5752c75a556a06c4d3a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a2cdc6182abdd5752c75a556a06c4d3a0">resetPipeline</a> ()</td></tr>
<tr class="memdesc:a2cdc6182abdd5752c75a556a06c4d3a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">INTERNAL. reset the currently bound pipeline.  <a href="#a2cdc6182abdd5752c75a556a06c4d3a0">More...</a><br/></td></tr>
<tr class="separator:a2cdc6182abdd5752c75a556a06c4d3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a262f87242f78cabe6979a880603748b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a262f87242f78cabe6979a880603748b6">setBlendConstants</a> (pvr::float32 r, pvr::float32 g, pvr::float32 b, pvr::float32 a)</td></tr>
<tr class="memdesc:a262f87242f78cabe6979a880603748b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set blend constants for blend operation using constant colors.  <a href="#a262f87242f78cabe6979a880603748b6">More...</a><br/></td></tr>
<tr class="separator:a262f87242f78cabe6979a880603748b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9276a3b1720b910a2c2dd54dd4ae417a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a9276a3b1720b910a2c2dd54dd4ae417a">setDepthBias</a> (pvr::float32 depthBias, pvr::float32 depthBiasClamp, pvr::float32 slopeScaledDepthBias)</td></tr>
<tr class="separator:a9276a3b1720b910a2c2dd54dd4ae417a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66eb6d0bb8395e236cfe4273a8c3280f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a66eb6d0bb8395e236cfe4273a8c3280f">setDepthBound</a> (pvr::float32 min=0.0f, pvr::float32 max=1)</td></tr>
<tr class="memdesc:a66eb6d0bb8395e236cfe4273a8c3280f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set minimum and maximum depth.  <a href="#a66eb6d0bb8395e236cfe4273a8c3280f">More...</a><br/></td></tr>
<tr class="separator:a66eb6d0bb8395e236cfe4273a8c3280f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be66d76224250dd22543464b583fa4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a8be66d76224250dd22543464b583fa4a">setLineWidth</a> ()</td></tr>
<tr class="memdesc:a8be66d76224250dd22543464b583fa4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the line width.  <a href="#a8be66d76224250dd22543464b583fa4a">More...</a><br/></td></tr>
<tr class="separator:a8be66d76224250dd22543464b583fa4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87f7ad6fbb63bf3e997c2af0d81a331"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#ac87f7ad6fbb63bf3e997c2af0d81a331">setMemoryBarrier</a> (const <a class="el" href="classpvr_1_1api_1_1_pipeline_barrier.html">PipelineBarrier</a> &amp;barrier)</td></tr>
<tr class="memdesc:ac87f7ad6fbb63bf3e997c2af0d81a331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a memory barrier to the command stream, forcing preceeding commands to be written before succeeding commands are executed.  <a href="#ac87f7ad6fbb63bf3e997c2af0d81a331">More...</a><br/></td></tr>
<tr class="separator:ac87f7ad6fbb63bf3e997c2af0d81a331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc2efdf55fda8637e69a3131f10740d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a9cc2efdf55fda8637e69a3131f10740d">setScissor</a> (const pvr::Rectanglei &amp;scissor)</td></tr>
<tr class="memdesc:a9cc2efdf55fda8637e69a3131f10740d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the scissor rectangle.  <a href="#a9cc2efdf55fda8637e69a3131f10740d">More...</a><br/></td></tr>
<tr class="separator:a9cc2efdf55fda8637e69a3131f10740d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2f032337ffe811c70d5c449bfa9f88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a1d2f032337ffe811c70d5c449bfa9f88">setStencilCompareMask</a> (<a class="el" href="namespacepvr_1_1api_1_1_face.html#a7a2a061af66557bf899a1893efad6ed5">pvr::api::Face::Enum</a> face, pvr::uint32 compareMask)</td></tr>
<tr class="memdesc:a1d2f032337ffe811c70d5c449bfa9f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the stencil comparison mask.  <a href="#a1d2f032337ffe811c70d5c449bfa9f88">More...</a><br/></td></tr>
<tr class="separator:a1d2f032337ffe811c70d5c449bfa9f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d0ab31fa3bd9586c527f0ef095a909"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a76d0ab31fa3bd9586c527f0ef095a909">setStencilReference</a> (<a class="el" href="namespacepvr_1_1api_1_1_face.html#a7a2a061af66557bf899a1893efad6ed5">pvr::api::Face::Enum</a> face, pvr::uint32 <a class="el" href="_api_gles2_8h.html#a083de4c8e32ad3d9059245f26be721de">ref</a>)</td></tr>
<tr class="memdesc:a76d0ab31fa3bd9586c527f0ef095a909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set stencil reference value.  <a href="#a76d0ab31fa3bd9586c527f0ef095a909">More...</a><br/></td></tr>
<tr class="separator:a76d0ab31fa3bd9586c527f0ef095a909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2442c5c8a2dc3c458ed4204a2aa592fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a2442c5c8a2dc3c458ed4204a2aa592fe">setStencilWriteMask</a> (<a class="el" href="namespacepvr_1_1api_1_1_face.html#a7a2a061af66557bf899a1893efad6ed5">pvr::api::Face::Enum</a> face, pvr::uint32 writeMask)</td></tr>
<tr class="memdesc:a2442c5c8a2dc3c458ed4204a2aa592fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the stencil write mask.  <a href="#a2442c5c8a2dc3c458ed4204a2aa592fe">More...</a><br/></td></tr>
<tr class="separator:a2442c5c8a2dc3c458ed4204a2aa592fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5788b49a2711b621aa2efd7500c14ff6"><td class="memTemplParams" colspan="2">template&lt;typename _type &gt; </td></tr>
<tr class="memitem:a5788b49a2711b621aa2efd7500c14ff6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a5788b49a2711b621aa2efd7500c14ff6">setUniform</a> (int32 <a class="el" href="_api_gles2_8h.html#a6f0165ed903f22b8bb600c3e0b628e73">location</a>, const _type &amp;<a class="el" href="_api_gles31_8h.html#aa857b95cc76669c2a9109239ef40a47c">val</a>)</td></tr>
<tr class="memdesc:a5788b49a2711b621aa2efd7500c14ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use.  <a href="#a5788b49a2711b621aa2efd7500c14ff6">More...</a><br/></td></tr>
<tr class="separator:a5788b49a2711b621aa2efd7500c14ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3121cfba7873242311eaae6e11d0e796"><td class="memTemplParams" colspan="2">template&lt;typename _type &gt; </td></tr>
<tr class="memitem:a3121cfba7873242311eaae6e11d0e796"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a3121cfba7873242311eaae6e11d0e796">setUniformPtr</a> (int32 <a class="el" href="_api_gles2_8h.html#a6f0165ed903f22b8bb600c3e0b628e73">location</a>, pvr::uint32 <a class="el" href="_api_gles2_8h.html#a5b40aca7a9682963dd00a8f5aef0a901">count</a>, const _type *ptr)</td></tr>
<tr class="memdesc:a3121cfba7873242311eaae6e11d0e796"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#a3121cfba7873242311eaae6e11d0e796">More...</a><br/></td></tr>
<tr class="separator:a3121cfba7873242311eaae6e11d0e796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439343e7e2554491d3e07014ad9b851b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a439343e7e2554491d3e07014ad9b851b">setViewport</a> (const pvr::Rectanglei &amp;viewport)</td></tr>
<tr class="memdesc:a439343e7e2554491d3e07014ad9b851b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the viewport rectangle.  <a href="#a439343e7e2554491d3e07014ad9b851b">More...</a><br/></td></tr>
<tr class="separator:a439343e7e2554491d3e07014ad9b851b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:af7fff67b6385c502289138bd43e57fc6"><td class="memItemLeft" align="right" valign="top">typedef ListOfInterfaces<br class="typebreak"/>
&lt; <a class="el" href="classpvr_1_1api_1_1_api_command.html">ApiCommand</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#af7fff67b6385c502289138bd43e57fc6">CommandQueue</a></td></tr>
<tr class="memdesc:af7fff67b6385c502289138bd43e57fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special class optimizing the memory layout of the command queue.  <a href="#af7fff67b6385c502289138bd43e57fc6">More...</a><br/></td></tr>
<tr class="separator:af7fff67b6385c502289138bd43e57fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:afc6f3686341d6ee8f00e0138cd5510a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#afc6f3686341d6ee8f00e0138cd5510a8">CommandBufferBaseImpl</a> (GraphicsContext &amp;<a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#aee648339f43657376dd7377f7d058f22">context</a>)</td></tr>
<tr class="separator:afc6f3686341d6ee8f00e0138cd5510a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1b481e8343bb6c5368b783505765e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a0c1b481e8343bb6c5368b783505765e0">CommandBufferBaseImpl</a> ()</td></tr>
<tr class="separator:a0c1b481e8343bb6c5368b783505765e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4e4067336ecf0d35f80458d7861e37"><td class="memTemplParams" colspan="2">template&lt;typename ClassType , typename ObjectType &gt; </td></tr>
<tr class="memitem:acf4e4067336ecf0d35f80458d7861e37"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#acf4e4067336ecf0d35f80458d7861e37">enqueue_internal</a> (const ObjectType &amp;obj)</td></tr>
<tr class="separator:acf4e4067336ecf0d35f80458d7861e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ef90e27af87c1d502fe215befa0a95"><td class="memTemplParams" colspan="2">template&lt;typename ClassType , typename ObjectType , typename ParamType &gt; </td></tr>
<tr class="memitem:a18ef90e27af87c1d502fe215befa0a95"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a18ef90e27af87c1d502fe215befa0a95">enqueue_internal</a> (ObjectType &amp;obj, ParamType &amp;par)</td></tr>
<tr class="separator:a18ef90e27af87c1d502fe215befa0a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39fcd45271ef4484905c97e4ce03719"><td class="memTemplParams" colspan="2">template&lt;typename iterator &gt; </td></tr>
<tr class="memitem:ad39fcd45271ef4484905c97e4ce03719"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#ad39fcd45271ef4484905c97e4ce03719">execute_iterator</a> (iterator &amp;it)</td></tr>
<tr class="separator:ad39fcd45271ef4484905c97e4ce03719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fa04f525650b99559baa79a7271aed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#ae2fa04f525650b99559baa79a7271aed">submit</a> ()</td></tr>
<tr class="separator:ae2fa04f525650b99559baa79a7271aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e3415522653edb9010d7bdc9509985"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#aa1e3415522653edb9010d7bdc9509985">valdidateRecordState</a> ()</td></tr>
<tr class="separator:aa1e3415522653edb9010d7bdc9509985"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aee648339f43657376dd7377f7d058f22"><td class="memItemLeft" align="right" valign="top">GraphicsContext&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#aee648339f43657376dd7377f7d058f22">context</a></td></tr>
<tr class="separator:aee648339f43657376dd7377f7d058f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2086b389cecdb477dbeefe8a61d317a3"><td class="memItemLeft" align="right" valign="top">native::HCommandBuffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a2086b389cecdb477dbeefe8a61d317a3">m_cmdBuffer</a></td></tr>
<tr class="separator:a2086b389cecdb477dbeefe8a61d317a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4aa401c9286ce3b5187b1ca7e126b5f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#ab4aa401c9286ce3b5187b1ca7e126b5f">m_isRecording</a></td></tr>
<tr class="separator:ab4aa401c9286ce3b5187b1ca7e126b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2da85116b89a80a535c9cb784466764"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr_1_1api_1_1_render_pass_contents.html#aeebeac762598065361d96782d2158ab5">RenderPassContents::Enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#ad2da85116b89a80a535c9cb784466764">m_nextSubPassContent</a></td></tr>
<tr class="separator:ad2da85116b89a80a535c9cb784466764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795fc15b292735a0050d70a56c5683b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#af7fff67b6385c502289138bd43e57fc6">CommandQueue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#a795fc15b292735a0050d70a56c5683b5">queue</a></td></tr>
<tr class="separator:a795fc15b292735a0050d70a56c5683b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains all the commands and states that need to be submitted to the gpu, including pipeline, texture, and samplers. Virtually everything that needs to happen on the GPU is submitted to the CommandBuffer. In debug builds (define DEBUG or define PVR_STORE_STACK_TRACE_WITH_API_COMMANDS), a limited stack trace is stored with each command so that if an error occurs, the site where the command was actually added to the command buffer can be determined. </p>
<hr/>
<p> Primary command buffers can contain RenderPasses, and can be submitted to the GPU. Secondary command buffers cannot contain RenderPasses, and can be enqueued to PrimaryCommandBuffers.</p>
<p>-It is invalid to submit commands to a command buffer while it is not being recorded. -It is invalid to reset a command buffer while it is being recorded. -It is invalid to submit a command buffer more than once if it is one time submit command buffer </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="af7fff67b6385c502289138bd43e57fc6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef ListOfInterfaces&lt;<a class="el" href="classpvr_1_1api_1_1_api_command.html">ApiCommand</a>&gt; <a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#af7fff67b6385c502289138bd43e57fc6">pvr::api::impl::CommandBufferBaseImpl::CommandQueue</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Special class optimizing the memory layout of the command queue. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2d9b06daf680e0dbc19a8f8c9dfc8dda"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual pvr::api::impl::CommandBufferBaseImpl::~CommandBufferBaseImpl </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. Frees all resources. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="afc6f3686341d6ee8f00e0138cd5510a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvr::api::impl::CommandBufferBaseImpl::CommandBufferBaseImpl </td>
          <td>(</td>
          <td class="paramtype">GraphicsContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0c1b481e8343bb6c5368b783505765e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvr::api::impl::CommandBufferBaseImpl::CommandBufferBaseImpl </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a721f2afa698ea20a3a8f38ca5e571833"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::beginRecording </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this function before beginning to record commands. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="a595b5ae58675dde002a875befecbf50d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::bindDescriptorSets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr_1_1api_1_1_pipeline_binding_point.html#a321e31cba9cffb8c4fc858ac34ebec8f">PipelineBindingPoint::Enum</a>&#160;</td>
          <td class="paramname"><em>bindingPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const api::PipelineLayout &amp;&#160;</td>
          <td class="paramname"><em>pipelineLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DescriptorSet &amp;&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>dynamicOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind a single DescriptorSet. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bindingPoint</td><td>The index of the descriptor set to bind to </td></tr>
    <tr><td class="paramname">pipelineLayout</td><td>The pipelineLayout that the GraphicsPipeline will have </td></tr>
    <tr><td class="paramname">set</td><td>The descriptorSet to bind to the binding point bindingPoint </td></tr>
    <tr><td class="paramname">dynamicOffset</td><td>The Offset that will be used when binding items of this descriptor set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af2ce38348ce724cf709cdd94dd1d521d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::bindDescriptorSets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr_1_1api_1_1_pipeline_binding_point.html#a321e31cba9cffb8c4fc858ac34ebec8f">PipelineBindingPoint::Enum</a>&#160;</td>
          <td class="paramname"><em>bindingPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const api::PipelineLayout &amp;&#160;</td>
          <td class="paramname"><em>pipelineLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DescriptorSet *&#160;</td>
          <td class="paramname"><em>sets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 *&#160;</td>
          <td class="paramname"><em>dynamicOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind multiple DescriptorSets. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bindingPoint</td><td>The index where the first descriptor set will bind to. The rest will be bound successively. </td></tr>
    <tr><td class="paramname">pipelineLayout</td><td>The pipelineLayout that the GraphicsPipeline will have </td></tr>
    <tr><td class="paramname">sets</td><td>The array of descriptorSets to bind to the binding points </td></tr>
    <tr><td class="paramname">dynamicOffsets</td><td>An array of Offsets that will be used when binding items of this descriptor set respectively </td></tr>
    <tr><td class="paramname">count</td><td>The number of descriptor sets in the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8f0b4abd6adbaa52e4dadfcd1fa0c3eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::bindIndexBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpvr_1_1api_1_1_buffer.html">api::Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexType::Enum&#160;</td>
          <td class="paramname"><em>indexType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind an index buffer for drawing. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to bind as an IndexBuffer </td></tr>
    <tr><td class="paramname">offset</td><td>The offset into the Index buffer to bind </td></tr>
    <tr><td class="paramname">indexType</td><td>the type of indices the buffer contains </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a12099cfcd5202d7f4bd32a99775c2156"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::bindPipeline </td>
          <td>(</td>
          <td class="paramtype">GraphicsPipeline &amp;&#160;</td>
          <td class="paramname"><em>pipeline</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind a graphics pipeline. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipeline</td><td>The GraphicsPipeline to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a908a1e8ff752979afdd0f7a1879f9ea1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::bindPipeline </td>
          <td>(</td>
          <td class="paramtype">ParentableGraphicsPipeline &amp;&#160;</td>
          <td class="paramname"><em>pipeline</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind a parentable graphics pipeline. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipeline</td><td>The ParentableGraphicsPipeline to bind </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a463fa2ed3ba1b1075b677ae6f1991e33"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::bindPipeline </td>
          <td>(</td>
          <td class="paramtype">ComputePipeline &amp;&#160;</td>
          <td class="paramname"><em>pipeline</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind a compute pipeline. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipeline</td><td>The ComputePipeline to bind </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab9ccdc490c34800343f488b60fe96625"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::bindVertexBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpvr_1_1api_1_1_buffer.html">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>bindingIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind a Vertex <a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">Buffer</a> for drawing. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The vertex buffer to bind </td></tr>
    <tr><td class="paramname">offset</td><td>The offset into the vertex buffer to bind </td></tr>
    <tr><td class="paramname">bindingIndex</td><td>The Vertex <a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">Buffer</a> index to bind the vertex buffer to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac92596393c46edc459b5da7e720fdd1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::bindVertexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1api_1_1_buffer.html">Buffer</a> const *&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>startBinding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>bindingCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind an array of Vertex Buffers. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The array of buffers </td></tr>
    <tr><td class="paramname">offsets</td><td>The array of offsets into the vertex buffer, each corresponding to a vertex buffer </td></tr>
    <tr><td class="paramname">startBinding</td><td>The binding index that the first buffer will be bound </td></tr>
    <tr><td class="paramname">numBuffers</td><td>The number of buffers to bind </td></tr>
    <tr><td class="paramname">bindingCount</td><td>The number of bindings </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9e9a837a39fca41d008b56b6b7f46cf5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::clear </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the command queue. It is invalid to clear the command buffer while it is being recorded. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="a0347f25ee9dc17043ba09fb2b4e9a220"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::clearColorAttachment </td>
          <td>(</td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>attachmentCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec4 const *&#160;</td>
          <td class="paramname"><em>clearColors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvr::Rectanglei *&#160;</td>
          <td class="paramname"><em>rects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear multiple attachments with separate clear colors and clear rectangle for each. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attachmentCount</td><td>Number of attachments to clear </td></tr>
    <tr><td class="paramname">clearColors</td><td>An array of colors to clear to, each corresponding to an attachment </td></tr>
    <tr><td class="paramname">rects</td><td>An array of rectangles, each corresponding to the clear area of an attachment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a58ddd610781c061bdd9dfff7e8a25f02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::clearColorAttachment </td>
          <td>(</td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>attachmentCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec4&#160;</td>
          <td class="paramname"><em>clearColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvr::Rectanglei&#160;</td>
          <td class="paramname"><em>rect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear multiple attachment with a single clear color and a single rectangle. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attachmentCount</td><td>The number of attachments </td></tr>
    <tr><td class="paramname">clearColor</td><td>The clear area </td></tr>
    <tr><td class="paramname">rect</td><td>The rectangle to clear </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8e96fd756b887c4e6e2a0439bf1d820e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::clearDepthAttachment </td>
          <td>(</td>
          <td class="paramtype">const pvr::Rectanglei &amp;&#160;</td>
          <td class="paramname"><em>clearRect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32&#160;</td>
          <td class="paramname"><em>depth</em> = <code>1.<a class="el" href="_api_gles2_8h.html#a0fdda94b8b7e64884690244028f455ba">f</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the depth attachment of an fbo. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clearRect</td><td>The clear area </td></tr>
    <tr><td class="paramname">depth</td><td>The clear value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4698b949015f61ad7c76d5dc25bab248"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::clearDepthStencilAttachment </td>
          <td>(</td>
          <td class="paramtype">const pvr::Rectanglei &amp;&#160;</td>
          <td class="paramname"><em>clearRect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32&#160;</td>
          <td class="paramname"><em>depth</em> = <code>1.<a class="el" href="_api_gles2_8h.html#a0fdda94b8b7e64884690244028f455ba">f</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::int32&#160;</td>
          <td class="paramname"><em>stencil</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the depth stencil attachment. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clearRect</td><td>clear area </td></tr>
    <tr><td class="paramname">depth</td><td>The depth clear value </td></tr>
    <tr><td class="paramname">stencil</td><td>The stencil clear value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af23d64521e8c24b3e78e90f899b2f57e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::clearStencilAttachment </td>
          <td>(</td>
          <td class="paramtype">const pvr::Rectanglei &amp;&#160;</td>
          <td class="paramname"><em>clearRect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::int32&#160;</td>
          <td class="paramname"><em>stencil</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the stencil attachment of an fbo. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clearRect</td><td>The clear area </td></tr>
    <tr><td class="paramname">stencil</td><td>The clear value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a367ecb19a73d906164dd0d4903ca66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::dispatchCompute </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numGroupsX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numGroupsY</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numGroupsZ</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enqueues a ComputeShader execution using the ComputeShader that is in the currently bound ComputePipeline. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numGroupsX</td><td>The number of workgroups enqueued in the X direction. </td></tr>
    <tr><td class="paramname">numGroupsY</td><td>The number of workgroups enqueued in the Y direction (default 1). </td></tr>
    <tr><td class="paramname">numGroupsZ</td><td>The number of workgroups enqueued in the Z direction (default 1). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af462cb102f76680063615bcebb726885"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::drawArrays </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>firstVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>firstInstance</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>instanceCount</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw command. Use the current state in the command buffer (pipelines, buffers, descriptor sets) to execute a drawing command. Does not use an IndexBuffer. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstVertex</td><td>The vertex from where to start drawing </td></tr>
    <tr><td class="paramname">vertexCount</td><td>The number of vertices to draw </td></tr>
    <tr><td class="paramname">firstInstance</td><td>The Instance from which to draw from </td></tr>
    <tr><td class="paramname">instanceCount</td><td>The number of instances to draw </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a32fc17d096f7064ac969958202e5ef4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::drawIndexed </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>firstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>indexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>vertexOffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>firstInstance</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>instanceCount</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw command. Use the current state in the command buffer (pipelines, buffers, descriptor sets) to execute a drawing command. Uses the currently bound IndexBuffer for indexes into the currently bound VBOs. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstIndex</td><td>Offset into the Index buffer to start drawing from </td></tr>
    <tr><td class="paramname">indexCount</td><td>The number of indexes to draw </td></tr>
    <tr><td class="paramname">vertexOffset</td><td>Index into the Vertex <a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">Buffer</a> to start drawing from </td></tr>
    <tr><td class="paramname">firstInstance</td><td>The Instance from which to draw from </td></tr>
    <tr><td class="paramname">instanceCount</td><td>The number of instances to draw </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6f955fe4db46fb3efd73a320a92a5ff9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::drawIndexedIndirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1api_1_1_buffer.html">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indirect Draw command. Use buffer to obtain the draw call parameters. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A buffer containing the draw call parameters in the form of a DrawIndexedIndirectCommand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1b1816c4245c3afdffe2e06cca36a707"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::drawIndirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1api_1_1_buffer.html">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw indirect. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="a698056509d1cbede4e8e830c4e0d0423"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::endRecording </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this function when you are done recording commands. BeginRecording must be called first. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="acf4e4067336ecf0d35f80458d7861e37"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ClassType , typename ObjectType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::enqueue_internal </td>
          <td>(</td>
          <td class="paramtype">const ObjectType &amp;&#160;</td>
          <td class="paramname"><em>obj</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a18ef90e27af87c1d502fe215befa0a95"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ClassType , typename ObjectType , typename ParamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::enqueue_internal </td>
          <td>(</td>
          <td class="paramtype">ObjectType &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParamType &amp;&#160;</td>
          <td class="paramname"><em>par</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad39fcd45271ef4484905c97e4ce03719"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::execute_iterator </td>
          <td>(</td>
          <td class="paramtype">iterator &amp;&#160;</td>
          <td class="paramname"><em>it</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6095737c196cb06e52bd69e4aff9372a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GraphicsContext&amp; pvr::api::impl::CommandBufferBaseImpl::getContext </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the context used by this CommandBuffer. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="a500ef1a3c200d246e4d36c5378e5e3a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr_1_1api.html#aed7be4927619057cc4c9f136198da2f5">Sync</a> pvr::api::impl::CommandBufferBaseImpl::insertFenceSync </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a synchronization object collection to the command stream and return its handle to the user. The user may then use the sync points for a configurable number of command buffer submition. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>A Sync object (collection of Sync points) representing (consecutive) submissions of this command buffer </dd></dl>

</div>
</div>
<a class="anchor" id="a285ae290613736990812f4ff4dcaf6d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::api::impl::CommandBufferBaseImpl::isRecording </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queries if a command buffer is in the recording state. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>True if recording, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a19fac5486f7a1bfebaffdcfdfbe05689"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::popPipeline </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind the previously pushed pipeline (See pushGraphicsPipeline) </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="ac57ddf2a5c75e323537c94ceb24e65ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::pushPipeline </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store which pipeline is currently bound, so that it can later be retrieved and bound with a popPipeline command. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="a2cdc6182abdd5752c75a556a06c4d3a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::resetPipeline </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>INTERNAL. reset the currently bound pipeline. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="a262f87242f78cabe6979a880603748b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::setBlendConstants </td>
          <td>(</td>
          <td class="paramtype">pvr::float32&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::float32&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::float32&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::float32&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set blend constants for blend operation using constant colors. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Red blend constant </td></tr>
    <tr><td class="paramname">g</td><td>Green blend constant </td></tr>
    <tr><td class="paramname">b</td><td>Blue blend constant </td></tr>
    <tr><td class="paramname">a</td><td>Alpha blend constant </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9276a3b1720b910a2c2dd54dd4ae417a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::setDepthBias </td>
          <td>(</td>
          <td class="paramtype">pvr::float32&#160;</td>
          <td class="paramname"><em>depthBias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::float32&#160;</td>
          <td class="paramname"><em>depthBiasClamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::float32&#160;</td>
          <td class="paramname"><em>slopeScaledDepthBias</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a66eb6d0bb8395e236cfe4273a8c3280f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::setDepthBound </td>
          <td>(</td>
          <td class="paramtype">pvr::float32&#160;</td>
          <td class="paramname"><em>min</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::float32&#160;</td>
          <td class="paramname"><em>max</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set minimum and maximum depth. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>Minimum depth (default 0.0f) </td></tr>
    <tr><td class="paramname">max</td><td>Maximum depth (default 1.0f) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8be66d76224250dd22543464b583fa4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::setLineWidth </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the line width. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="ac87f7ad6fbb63bf3e997c2af0d81a331"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::setMemoryBarrier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpvr_1_1api_1_1_pipeline_barrier.html">PipelineBarrier</a> &amp;&#160;</td>
          <td class="paramname"><em>barrier</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a memory barrier to the command stream, forcing preceeding commands to be written before succeeding commands are executed. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="a9cc2efdf55fda8637e69a3131f10740d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::setScissor </td>
          <td>(</td>
          <td class="paramtype">const pvr::Rectanglei &amp;&#160;</td>
          <td class="paramname"><em>scissor</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the scissor rectangle. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scissor</td><td>The scissor rectangle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1d2f032337ffe811c70d5c449bfa9f88"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::setStencilCompareMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr_1_1api_1_1_face.html#a7a2a061af66557bf899a1893efad6ed5">pvr::api::Face::Enum</a>&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>compareMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the stencil comparison mask. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>The face/faces for which to set the stencil mask </td></tr>
    <tr><td class="paramname">compareMask</td><td>A uint32 which will mask both the values and the reference before stencil comparisons </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a76d0ab31fa3bd9586c527f0ef095a909"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::setStencilReference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr_1_1api_1_1_face.html#a7a2a061af66557bf899a1893efad6ed5">pvr::api::Face::Enum</a>&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set stencil reference value. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>The face/faces for which to set the stencil reference value </td></tr>
    <tr><td class="paramname">ref</td><td>The stencil reference value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2442c5c8a2dc3c458ed4204a2aa592fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::setStencilWriteMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr_1_1api_1_1_face.html#a7a2a061af66557bf899a1893efad6ed5">pvr::api::Face::Enum</a>&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>writeMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the stencil write mask. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>The face/faces for which to set the stencil write mask </td></tr>
    <tr><td class="paramname">writeMask</td><td>A uint32 which will mask the values when writing the stencil </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5788b49a2711b621aa2efd7500c14ff6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::setUniform </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _type &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. </p>
<hr/>
 <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_type</td><td>The type of item to upload to the uniform. Supported types depend on the underlying API and shader glsl version. Vectors and matrices should be uploaded using the glm::vec/mat types (not float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">val</td><td>The value. Although passed by const-ref, it will immediately be copied and stored internally </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Description:</dt><dd>Due to the value being fixed until the command buffer is re-recorder, the usefulness of this command is limited. See setUniformPtr. </dd></dl>

</div>
</div>
<a class="anchor" id="a3121cfba7873242311eaae6e11d0e796"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::setUniformPtr </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _type *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform. </p>
<hr/>
 <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_type</td><td>The type of item to upload to the uniform. Supported types depend on the underlying API and shader glsl version. Vectors and matrices should be uploaded using the glm::vec/mat types (not float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">count</td><td>The number of values to read from the pointer </td></tr>
    <tr><td class="paramname">ptr</td><td>A pointer to a location that shall remain fixed as long as the command buffer is used (unless cleared). The value will be read from ptr and the uniform updated every time the command buffer is submitted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Description:</dt><dd>WARNING: This memory location is intended to be fixed, and must remain live as long as the command buffer is used, since every time the command buffer is submitted, this memory location will be read. In synchronous underlying APIs (OGLES) the value can be changed freely without any synchronization before submitting the command buffer or after it returns. Uploading arrays of values is supported. </dd></dl>

</div>
</div>
<a class="anchor" id="a439343e7e2554491d3e07014ad9b851b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::setViewport </td>
          <td>(</td>
          <td class="paramtype">const pvr::Rectanglei &amp;&#160;</td>
          <td class="paramname"><em>viewport</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the viewport rectangle. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">viewport</td><td>The viewport rectangle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae2fa04f525650b99559baa79a7271aed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::impl::CommandBufferBaseImpl::submit </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa1e3415522653edb9010d7bdc9509985"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::api::impl::CommandBufferBaseImpl::valdidateRecordState </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aee648339f43657376dd7377f7d058f22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GraphicsContext pvr::api::impl::CommandBufferBaseImpl::context</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2086b389cecdb477dbeefe8a61d317a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">native::HCommandBuffer pvr::api::impl::CommandBufferBaseImpl::m_cmdBuffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab4aa401c9286ce3b5187b1ca7e126b5f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::api::impl::CommandBufferBaseImpl::m_isRecording</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad2da85116b89a80a535c9cb784466764"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr_1_1api_1_1_render_pass_contents.html#aeebeac762598065361d96782d2158ab5">RenderPassContents::Enum</a> pvr::api::impl::CommandBufferBaseImpl::m_nextSubPassContent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a795fc15b292735a0050d70a56c5683b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base_impl.html#af7fff67b6385c502289138bd43e57fc6">CommandQueue</a> pvr::api::impl::CommandBufferBaseImpl::queue</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/dev/buildxl/buildroot/sdk/branch/Framework/PVRApi/ApiObjects/<a class="el" href="_command_buffer_8h_source.html">CommandBuffer.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
