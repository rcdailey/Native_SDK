<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.4"/>
<title>PVRApi: pvr::api Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%" border="none"/></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRApi</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="namespacepvr_1_1api.html">api</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">pvr::api Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Main PVRApi Namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacepvr_1_1api_1_1_blend_factor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api_1_1_blend_factor.html">BlendFactor</a></td></tr>
<tr class="memdesc:namespacepvr_1_1api_1_1_blend_factor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specfies how the rgba blending facors are computed for source and destination fragments. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1api_1_1_blend_op"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api_1_1_blend_op.html">BlendOp</a></td></tr>
<tr class="memdesc:namespacepvr_1_1api_1_1_blend_op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of the blend operations (determine how a new pixel (source color) is combined with a pixel already in the framebuffer (destination color). <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1api_1_1_cmd_buffer_optimize_flags"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api_1_1_cmd_buffer_optimize_flags.html">CmdBufferOptimizeFlags</a></td></tr>
<tr class="memdesc:namespacepvr_1_1api_1_1_cmd_buffer_optimize_flags"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of optimisation flags for CommandBuffers. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1api_1_1_color_channel"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api_1_1_color_channel.html">ColorChannel</a></td></tr>
<tr class="memdesc:namespacepvr_1_1api_1_1_color_channel"><td class="mdescLeft">&#160;</td><td class="mdescRight">ChannelWriteMask enable/ disable writting to channel bits. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1api_1_1_convert_to_gles"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api_1_1_convert_to_gles.html">ConvertToGles</a></td></tr>
<tr class="memdesc:namespacepvr_1_1api_1_1_convert_to_gles"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contain functions to convert several PowerVR Framework types to their Native, OpenGL ES representations, usually, from an enumeration to a GLenum. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1api_1_1_coordinate_origin"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api_1_1_coordinate_origin.html">CoordinateOrigin</a></td></tr>
<tr class="memdesc:namespacepvr_1_1api_1_1_coordinate_origin"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of Coordinate Origins. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1api_1_1_depth_mode"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api_1_1_depth_mode.html">DepthMode</a></td></tr>
<tr class="memdesc:namespacepvr_1_1api_1_1_depth_mode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Depth Range Mode. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1api_1_1_descriptor_type"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api_1_1_descriptor_type.html">DescriptorType</a></td></tr>
<tr class="memdesc:namespacepvr_1_1api_1_1_descriptor_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of all the different descriptor types. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1api_1_1_face"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api_1_1_face.html">Face</a></td></tr>
<tr class="memdesc:namespacepvr_1_1api_1_1_face"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of <a class="el" href="namespacepvr_1_1api_1_1_face.html" title="Enumeration of Face facing (front, back...). ">Face</a> facing (front, back...). <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1api_1_1_fbo_attachment_type"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api_1_1_fbo_attachment_type.html">FboAttachmentType</a></td></tr>
<tr class="memdesc:namespacepvr_1_1api_1_1_fbo_attachment_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of the possible types of FrameBufferObject attachment (depth, stencil, depthstencil, color). <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1api_1_1_fbo_binding_target"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api_1_1_fbo_binding_target.html">FboBindingTarget</a></td></tr>
<tr class="memdesc:namespacepvr_1_1api_1_1_fbo_binding_target"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of the possible binding points of a Framebuffer Object (Read, Write, ReadWrite). <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1api_1_1_fbo_texture_target"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api_1_1_fbo_texture_target.html">FboTextureTarget</a></td></tr>
<tr class="memdesc:namespacepvr_1_1api_1_1_fbo_texture_target"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of all FrameBufferObject texture targets. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1api_1_1_fill_mode"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api_1_1_fill_mode.html">FillMode</a></td></tr>
<tr class="memdesc:namespacepvr_1_1api_1_1_fill_mode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of polygon filling modes. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1api_1_1gpu_capabilities"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api_1_1gpu_capabilities.html">gpuCapabilities</a></td></tr>
<tr class="memdesc:namespacepvr_1_1api_1_1gpu_capabilities"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains enumerations for GPU capability queries. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1api_1_1_image_aspect"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api_1_1_image_aspect.html">ImageAspect</a></td></tr>
<tr class="memdesc:namespacepvr_1_1api_1_1_image_aspect"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of the "aspect" (or "semantics") of an image: Color, Depth, Stencil. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1api_1_1impl"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api_1_1impl.html">impl</a></td></tr>
<tr class="memdesc:namespacepvr_1_1api_1_1impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains internal objects and wrapped versions of the PVRApi module. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1api_1_1_interpolation_mode"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api_1_1_interpolation_mode.html">InterpolationMode</a></td></tr>
<tr class="memdesc:namespacepvr_1_1api_1_1_interpolation_mode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of Interpolation types for Samplers (nearest, linear). <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1api_1_1_logic_op"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api_1_1_logic_op.html">LogicOp</a></td></tr>
<tr class="memdesc:namespacepvr_1_1api_1_1_logic_op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logic operations (toggle, clear, and etc.). <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1api_1_1_mem_barrier_flag_in"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api_1_1_mem_barrier_flag_in.html">MemBarrierFlagIn</a></td></tr>
<tr class="memdesc:namespacepvr_1_1api_1_1_mem_barrier_flag_in"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of all the different input flags that can be used in the MemoryBarrier command. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1api_1_1_mem_barrier_flagout"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api_1_1_mem_barrier_flagout.html">MemBarrierFlagout</a></td></tr>
<tr class="memdesc:namespacepvr_1_1api_1_1_mem_barrier_flagout"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of all the different output flags that can be used in the MemoryBarrier command. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1api_1_1_pipeline_binding_point"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api_1_1_pipeline_binding_point.html">PipelineBindingPoint</a></td></tr>
<tr class="memdesc:namespacepvr_1_1api_1_1_pipeline_binding_point"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of the possible types of a Pipeline Binding point (Graphics, Compute). <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1api_1_1pipeline_creation"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api_1_1pipeline_creation.html">pipelineCreation</a></td></tr>
<tr class="memdesc:namespacepvr_1_1api_1_1pipeline_creation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains structs required to set different parameters of the GraphicsPipeline and ComputePipeline objects. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1api_1_1_polygon_winding_order"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api_1_1_polygon_winding_order.html">PolygonWindingOrder</a></td></tr>
<tr class="memdesc:namespacepvr_1_1api_1_1_polygon_winding_order"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of the different front face to winding order correlations. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1api_1_1_provoking_vertex"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api_1_1_provoking_vertex.html">ProvokingVertex</a></td></tr>
<tr class="memdesc:namespacepvr_1_1api_1_1_provoking_vertex"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of Provoking Vertex modes. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1api_1_1_render_pass_contents"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api_1_1_render_pass_contents.html">RenderPassContents</a></td></tr>
<tr class="memdesc:namespacepvr_1_1api_1_1_render_pass_contents"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of the possible way of recording commands for each subpasses of the render pass (Inline, SecondaryCommandBuffer). <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1api_1_1_sampler_compare_mode"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api_1_1_sampler_compare_mode.html">SamplerCompareMode</a></td></tr>
<tr class="memdesc:namespacepvr_1_1api_1_1_sampler_compare_mode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of comparison mode for comparison samplers. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1api_1_1_shader_stage_flags"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api_1_1_shader_stage_flags.html">ShaderStageFlags</a></td></tr>
<tr class="memdesc:namespacepvr_1_1api_1_1_shader_stage_flags"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of all shader stages. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1api_1_1_stencil_op"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api_1_1_stencil_op.html">StencilOp</a></td></tr>
<tr class="memdesc:namespacepvr_1_1api_1_1_stencil_op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of the different stencil operations. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1api_1_1_step_rate"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api_1_1_step_rate.html">StepRate</a></td></tr>
<tr class="memdesc:namespacepvr_1_1api_1_1_step_rate"><td class="mdescLeft">&#160;</td><td class="mdescRight">Step rate for a vertex attribute when drawing: Per vertex, per instance, per draw. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1api_1_1_swizzle_mask"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api_1_1_swizzle_mask.html">SwizzleMask</a></td></tr>
<tr class="memdesc:namespacepvr_1_1api_1_1_swizzle_mask"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of texture Swizzle mask channels. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1_api_command.html">ApiCommand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for Dynamic commands which can be queued into a CommandBuffer. In specific implementations, contains a stacktrace for the actual submission of the command into the commandbuffer, which can greatly assist debugging.  <a href="classpvr_1_1api_1_1_api_command.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1_asset_loading_delegate.html">AssetLoadingDelegate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for a class that can provide Asset Loading and Uploading. Used by PFX API parser and similar.  <a href="classpvr_1_1api_1_1_asset_loading_delegate.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1_asset_store.html">AssetStore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages scene assets. Use this class to easily load assets without needing to worry about duplicates. This class keeps references to assets, so remember to release them if they are no longer required.  <a href="classpvr_1_1api_1_1_asset_store.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1_atomic_buffer_view.html">AtomicBufferView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference-counted handle to an Atomic <a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">Buffer</a> object view of a <a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">Buffer</a>. Default constructor returns an empty handle that wraps a NULL object. Use the IGraphicsContext's createUbo to construct a <a class="el" href="classpvr_1_1api_1_1_atomic_buffer_view.html" title="Reference-counted handle to an Atomic Buffer object view of a Buffer. Default constructor returns an ...">AtomicBufferView</a>. As with all reference-counted handles, access with the arrow operator. For implementation details, see <a class="el" href="classpvr_1_1api_1_1impl_1_1_atomic_buffer_view_impl.html" title="See class pvr::api::AtomicBufferView. ">pvr::api::impl::AtomicBufferViewImpl</a>.  <a href="classpvr_1_1api_1_1_atomic_buffer_view.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1_buffer.html">Buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference-counted handle to a <a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">Buffer</a>. Default constructor returns an empty handle that wraps a NULL object. Use the IGraphicsContext's createUbo to construct a <a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">Buffer</a>. As with all reference-counted handles, access with the arrow operator. For implementation details, see <a class="el" href="classpvr_1_1api_1_1impl_1_1_buffer_impl.html" title="Buffer Implementation. Access through the Refcounted Framework object Buffer. All buffer types contai...">pvr::api::impl::BufferImpl</a>.  <a href="classpvr_1_1api_1_1_buffer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1api_1_1_color_attachment_view_create_param.html">ColorAttachmentViewCreateParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a TextureView with this class in order to use it as a Color Attachment in an FBO.  <a href="structpvr_1_1api_1_1_color_attachment_view_create_param.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1api_1_1_compressed_image_data_format.html">CompressedImageDataFormat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a Compressed format. Compressed formats provide less information than the uncompressed format, as they can only be accessed "black box".  <a href="structpvr_1_1api_1_1_compressed_image_data_format.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1api_1_1_compute_pipeline_create_param.html">ComputePipelineCreateParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute pipeline create parameters.  <a href="structpvr_1_1api_1_1_compute_pipeline_create_param.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1api_1_1_compute_state_container.html">ComputeStateContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">INTERNAL Contains all the states for compute pipeline.  <a href="structpvr_1_1api_1_1_compute_state_container.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1api_1_1_depth_stencil_view_create_param.html">DepthStencilViewCreateParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a TextureView with this class in order to use it as a Depth/Stencil Attachment in an FBO.  <a href="structpvr_1_1api_1_1_depth_stencil_view_create_param.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1api_1_1_descriptor_pool_create_param.html">DescriptorPoolCreateParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Descriptor Pool create parameter.  <a href="structpvr_1_1api_1_1_descriptor_pool_create_param.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1api_1_1_descriptor_set_layout_create_param.html">DescriptorSetLayoutCreateParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all information required to create a Descriptor Set Layout. This is the number of Textures, Samplers, Uniform <a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">Buffer</a> Objects, and Shader Storage <a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">Buffer</a> Objects bound for any shader stage.  <a href="structpvr_1_1api_1_1_descriptor_set_layout_create_param.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1api_1_1_descriptor_set_update_param.html">DescriptorSetUpdateParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all the information necessary to populate a Descriptor Set with the actual API objects. Use with the method update of the DescriptorSet. Populate this object with actual Descriptor objects (UBOs, textures etc).  <a href="structpvr_1_1api_1_1_descriptor_set_update_param.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1api_1_1_effect_api_program.html">EffectApiProgram</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Effect native shader program wrapper.  <a href="structpvr_1_1api_1_1_effect_api_program.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1api_1_1_effect_api_semantic.html">EffectApiSemantic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct containing GL uniform data.  <a href="structpvr_1_1api_1_1_effect_api_semantic.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1api_1_1_effect_api_shader.html">EffectApiShader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Effect shader info.  <a href="structpvr_1_1api_1_1_effect_api_shader.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1api_1_1_effect_api_texture_sampler.html">EffectApiTextureSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Texture wrapper for texture2d, texture3d and sampler.  <a href="structpvr_1_1api_1_1_effect_api_texture_sampler.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1api_1_1_fbo_create_param.html">FboCreateParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fbo creation descriptor.  <a href="structpvr_1_1api_1_1_fbo_create_param.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1api_1_1_graphics_pipeline_create_param.html">GraphicsPipelineCreateParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This represents al the information needed to create a GraphicsPipeline. All items must have proper values for a pipeline to be successfully created, but all those for which it is possible (except, for example, Shaders and Vertex Formats) will have defaults same as their default values OpenGL ES graphics API.  <a href="structpvr_1_1api_1_1_graphics_pipeline_create_param.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1_i_bindable.html">IBindable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for bindable objects. A bindable has a bind(IGraphicsContext) command.  <a href="classpvr_1_1api_1_1_i_bindable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1_i_index_bindable.html">IIndexBindable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for index bindable. An index bindable can be bound to an indexed binding point : bind(IGraphicsContext, index).  <a href="classpvr_1_1api_1_1_i_index_bindable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1api_1_1_image_data_format.html">ImageDataFormat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an image format, including pixel format(channels/bits per channel), datatype and colorspace.  <a href="structpvr_1_1api_1_1_image_data_format.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1api_1_1_image_storage_format.html">ImageStorageFormat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structpvr_1_1api_1_1_image_storage_format.html" title="ImageStorageFormat extends the ImageDataFormat with mipmaps and number of Samples. ">ImageStorageFormat</a> extends the <a class="el" href="structpvr_1_1api_1_1_image_data_format.html" title="Represents an image format, including pixel format(channels/bits per channel), datatype and colorspac...">ImageDataFormat</a> with mipmaps and number of Samples.  <a href="structpvr_1_1api_1_1_image_storage_format.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1api_1_1_image_storage_format_compressed.html">ImageStorageFormatCompressed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a Compressed format. Compressed formats provide less information than the uncompressed format, as they can only be accessed "black box".  <a href="structpvr_1_1api_1_1_image_storage_format_compressed.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1api_1_1_image_sub_resource_range.html">ImageSubResourceRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes an area of an image, out of which a SubResource can be defined. This area is a subarea of the image, containing a part of the image array slices, mip levels, or aspects.  <a href="structpvr_1_1api_1_1_image_sub_resource_range.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1_pipeline_barrier.html">PipelineBarrier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A memory barrier into the command stream. Used to signify that some types of pending operations from before the barrier must have finished before the commands after the barrier start executing.  <a href="classpvr_1_1api_1_1_pipeline_barrier.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1api_1_1_pipeline_layout_create_param.html">PipelineLayoutCreateParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipeline Layout create information. The descriptor set layouts must be known to create a Pipeline layout.  <a href="structpvr_1_1api_1_1_pipeline_layout_create_param.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1api_1_1_render_pass_color_info.html">RenderPassColorInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains information on the Color configuration of a renderpass (format, loadop, storeop, samples).  <a href="structpvr_1_1api_1_1_render_pass_color_info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1api_1_1_render_pass_create_param.html">RenderPassCreateParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RenderPass creation parameters. Fill this object and then use it to create a RenderPass through you IGraphicsContext.  <a href="structpvr_1_1api_1_1_render_pass_create_param.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1api_1_1_render_pass_depth_stencil_info.html">RenderPassDepthStencilInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains information on the Depth/Stencil configuration of a renderpass (format, loadops, storeops, samples).  <a href="structpvr_1_1api_1_1_render_pass_depth_stencil_info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1_ssbo_view.html">SsboView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference-counted handle to a Shader Storage <a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">Buffer</a> object view of a <a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">Buffer</a>. Default constructor returns an empty handle that wraps a NULL object. Use the IGraphicsContext's createUbo to construct a <a class="el" href="classpvr_1_1api_1_1_ssbo_view.html" title="Reference-counted handle to a Shader Storage Buffer object view of a Buffer. Default constructor retu...">SsboView</a>. As with all reference-counted handles, access with the arrow operator. For implementation details, see <a class="el" href="classpvr_1_1api_1_1impl_1_1_ssbo_view_impl.html" title="See class pvr::api::SsboView. ">pvr::api::impl::SsboViewImpl</a>.  <a href="classpvr_1_1api_1_1_ssbo_view.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1api_1_1_sub_pass.html">SubPass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render pass subpass. Subpasses allow intermediate draws to be chained and communicating with techniques like Pixel Local Storage without outputting to the FrameBuffer until the end of the RenderPass.  <a href="structpvr_1_1api_1_1_sub_pass.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1api_1_1_texture_area.html">TextureArea</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class used by texture update functions. Represents an area of the texture to be updated. Default value: width=1, height=1, (depth=1), offsetx=0,offsety=0,offsetz=0, arrayslice=0, cubeface=0, miplevel=0.  <a href="structpvr_1_1api_1_1_texture_area.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1_ubo_view.html">UboView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference-counted handle to a Uniform <a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">Buffer</a> object view of a <a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">Buffer</a>. Default constructor returns an empty handle that wraps a NULL object. Use the IGraphicsContext's createUbo to construct a <a class="el" href="classpvr_1_1api_1_1_ubo_view.html" title="Reference-counted handle to a Uniform Buffer object view of a Buffer. Default constructor returns an ...">UboView</a>. As with all reference-counted handles, access with the arrow operator. For implementation details, see <a class="el" href="classpvr_1_1api_1_1impl_1_1_ubo_view_impl.html" title="See class pvr::api::UboView. Create with pvr::api::IGraphicsContext::createUbo. ">pvr::api::impl::UboViewImpl</a>.  <a href="classpvr_1_1api_1_1_ubo_view.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1api_1_1_vertex_attribute_info.html">VertexAttributeInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains a full description of a Vertex Attribute: Index, format, number of elements, offset in the buffer, optionally name. All values (except attributeName) must be set explicitly.  <a href="structpvr_1_1api_1_1_vertex_attribute_info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1api_1_1_vertex_input_binding_info.html">VertexInputBindingInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about a <a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">Buffer</a> binding: Binding index, stride, (instance) step rate.  <a href="structpvr_1_1api_1_1_vertex_input_binding_info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8795856f3d769f5d37978c59e368f761"><td class="memItemLeft" align="right" valign="top">typedef RefCountedResource<br class="typebreak"/>
&lt; <a class="el" href="classpvr_1_1api_1_1impl_1_1_buffer_gles_impl.html">impl::BufferGlesImpl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api.html#a8795856f3d769f5d37978c59e368f761">BufferGles</a></td></tr>
<tr class="memdesc:a8795856f3d769f5d37978c59e368f761"><td class="mdescLeft">&#160;</td><td class="mdescRight">OpenGL ES implementation of the <a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">Buffer</a>.  <a href="#a8795856f3d769f5d37978c59e368f761">More...</a><br/></td></tr>
<tr class="separator:a8795856f3d769f5d37978c59e368f761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d935dcf60fe99740c37b6c56d7d7fbd"><td class="memItemLeft" align="right" valign="top">typedef RefCountedResource<br class="typebreak"/>
&lt; <a class="el" href="structpvr_1_1api_1_1impl_1_1_color_attachment_view_impl.html">impl::ColorAttachmentViewImpl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api.html#a8d935dcf60fe99740c37b6c56d7d7fbd">ColorAttachmentView</a></td></tr>
<tr class="separator:a8d935dcf60fe99740c37b6c56d7d7fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addcbe955a9af0d9edadc9ad107151699"><td class="memItemLeft" align="right" valign="top">typedef RefCountedResource<br class="typebreak"/>
&lt; <a class="el" href="classpvr_1_1api_1_1impl_1_1_default_fbo_gles_impl.html">impl::DefaultFboGlesImpl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api.html#addcbe955a9af0d9edadc9ad107151699">DefaultFboGles</a></td></tr>
<tr class="separator:addcbe955a9af0d9edadc9ad107151699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0099c6787d2b822573fa8f95c9fc3237"><td class="memItemLeft" align="right" valign="top">typedef RefCountedResource<br class="typebreak"/>
&lt; <a class="el" href="structpvr_1_1api_1_1impl_1_1_depth_stencil_view_impl.html">impl::DepthStencilViewImpl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api.html#a0099c6787d2b822573fa8f95c9fc3237">DepthStencilView</a></td></tr>
<tr class="separator:a0099c6787d2b822573fa8f95c9fc3237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8382a5c14d65fcf93385d2b4427dc3b8"><td class="memItemLeft" align="right" valign="top">typedef RefCountedResource<br class="typebreak"/>
&lt; <a class="el" href="classpvr_1_1api_1_1impl_1_1_descriptor_set_gles_impl.html">impl::DescriptorSetGlesImpl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api.html#a8382a5c14d65fcf93385d2b4427dc3b8">DescriptorSetGles</a></td></tr>
<tr class="separator:a8382a5c14d65fcf93385d2b4427dc3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279942732d36b5df3cac05bbf791233a"><td class="memItemLeft" align="right" valign="top">typedef RefCountedResource<br class="typebreak"/>
&lt; <a class="el" href="classpvr_1_1api_1_1impl_1_1_descriptor_set_layout_gles_impl.html">impl::DescriptorSetLayoutGlesImpl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api.html#a279942732d36b5df3cac05bbf791233a">DescriptorSetLayoutGles</a></td></tr>
<tr class="separator:a279942732d36b5df3cac05bbf791233a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9698b68c02758e0d33254850c950b768"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classpvr_1_1api_1_1impl_1_1_effect_api_impl.html#a9b208f790e7436cca78907f6b952f998">impl::EffectApiImpl::EffectApi_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api.html#a9698b68c02758e0d33254850c950b768">EffectApi</a></td></tr>
<tr class="separator:a9698b68c02758e0d33254850c950b768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13d37decce93d2f89d8c52ff7c7232d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpvr_1_1api_1_1impl_1_1_fbo_impl.html#a980dc3ed2fd7d85748e2073f4c7a64a0">impl::FboImpl::Fbo_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api.html#aa13d37decce93d2f89d8c52ff7c7232d">Fbo</a></td></tr>
<tr class="separator:aa13d37decce93d2f89d8c52ff7c7232d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c63964ff1d3b4179e038bb9a19f8f8"><td class="memItemLeft" align="right" valign="top">typedef RefCountedResource<br class="typebreak"/>
&lt; <a class="el" href="classpvr_1_1api_1_1impl_1_1_render_pass_impl.html">impl::RenderPassImpl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api.html#a67c63964ff1d3b4179e038bb9a19f8f8">RenderPass</a></td></tr>
<tr class="separator:a67c63964ff1d3b4179e038bb9a19f8f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc461c8a49bf816fba2c9e9c127cc914"><td class="memItemLeft" align="right" valign="top">typedef RefCountedResource<br class="typebreak"/>
&lt; <a class="el" href="classpvr_1_1api_1_1impl_1_1_shader_impl.html">impl::ShaderImpl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api.html#acc461c8a49bf816fba2c9e9c127cc914">Shader</a></td></tr>
<tr class="separator:acc461c8a49bf816fba2c9e9c127cc914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ddbbabd52684a2d9d4aeabdf126d9d8"><td class="memItemLeft" align="right" valign="top">typedef RefCountedResource<br class="typebreak"/>
&lt; <a class="el" href="classpvr_1_1api_1_1impl_1_1_shader_gles_impl.html">impl::ShaderGlesImpl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api.html#a9ddbbabd52684a2d9d4aeabdf126d9d8">ShaderGles</a></td></tr>
<tr class="separator:a9ddbbabd52684a2d9d4aeabdf126d9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed7be4927619057cc4c9f136198da2f5"><td class="memItemLeft" align="right" valign="top">typedef RefCountedResource<br class="typebreak"/>
&lt; <a class="el" href="classpvr_1_1api_1_1impl_1_1_sync_impl.html">impl::SyncImpl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api.html#aed7be4927619057cc4c9f136198da2f5">Sync</a></td></tr>
<tr class="memdesc:aed7be4927619057cc4c9f136198da2f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference-counted handle to a Sync object. Default constructor returns an empty handle that wraps a NULL object. Use the CommandBuffer's insertFenceSync to construct a Sync. As with all reference-counted handles, access with the arrow operator.  <a href="#aed7be4927619057cc4c9f136198da2f5">More...</a><br/></td></tr>
<tr class="separator:aed7be4927619057cc4c9f136198da2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a42b0a11877ad1979fc48afaf3fa548cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api.html#a42b0a11877ad1979fc48afaf3fa548cc">checkApiError</a> (<a class="el" href="_api_gles2_8h.html#ac83513893df92266f79a515488701770">string</a> *errOutStr=NULL)</td></tr>
<tr class="memdesc:a42b0a11877ad1979fc48afaf3fa548cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check and return api error.  <a href="#a42b0a11877ad1979fc48afaf3fa548cc">More...</a><br/></td></tr>
<tr class="separator:a42b0a11877ad1979fc48afaf3fa548cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6795b5b93ca36a985f4053a42654eb90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api.html#a6795b5b93ca36a985f4053a42654eb90">debugLogApiError</a> (const char *)</td></tr>
<tr class="memdesc:a6795b5b93ca36a985f4053a42654eb90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for API errors if the API supports them. If an error is detected, logs relevant error information. Only works in debug builds, and compiles to a NOP in release builds.  <a href="#a6795b5b93ca36a985f4053a42654eb90">More...</a><br/></td></tr>
<tr class="separator:a6795b5b93ca36a985f4053a42654eb90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb70e692b575d23fd009332d750f1147"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpvr_1_1api_1_1_image_data_format.html">api::ImageDataFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api.html#afb70e692b575d23fd009332d750f1147">getDisplayColorFormat</a> (const system::DisplayAttributes &amp;attribute)</td></tr>
<tr class="memdesc:afb70e692b575d23fd009332d750f1147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the color format from a Displaydisplay's color format.  <a href="#afb70e692b575d23fd009332d750f1147">More...</a><br/></td></tr>
<tr class="separator:afb70e692b575d23fd009332d750f1147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75df536ab883f7319c54866fd8010b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpvr_1_1api_1_1_image_data_format.html">api::ImageDataFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api.html#ae75df536ab883f7319c54866fd8010b1">getDisplayDepthStencilFormat</a> (const system::DisplayAttributes &amp;attribute)</td></tr>
<tr class="memdesc:ae75df536ab883f7319c54866fd8010b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the depth and/or stencil format from a Displaydisplay's color format.  <a href="#ae75df536ab883f7319c54866fd8010b1">More...</a><br/></td></tr>
<tr class="separator:ae75df536ab883f7319c54866fd8010b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a8d84c51eee8bb5bf9ee6a6aa361d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api.html#a81a8d84c51eee8bb5bf9ee6a6aa361d3">getDisplayFormat</a> (const system::DisplayAttributes &amp;attribute, <a class="el" href="structpvr_1_1api_1_1_image_data_format.html">api::ImageDataFormat</a> *outColorFmt, <a class="el" href="structpvr_1_1api_1_1_image_data_format.html">api::ImageDataFormat</a> *outDepthStencilFmt)</td></tr>
<tr class="memdesc:a81a8d84c51eee8bb5bf9ee6a6aa361d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the display's color, depth and or stencil format from a DisplayAttributes object.  <a href="#a81a8d84c51eee8bb5bf9ee6a6aa361d3">More...</a><br/></td></tr>
<tr class="separator:a81a8d84c51eee8bb5bf9ee6a6aa361d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eefd3048f55640cf576bd6b5c3afee8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api.html#a4eefd3048f55640cf576bd6b5c3afee8">logApiError</a> (const char *note, Logger::Severity <a class="el" href="_api_gles_ext_8h.html#acc39d4387d4f2d172de77ed0c5208990">severity</a>=Logger::Error)</td></tr>
<tr class="memdesc:a4eefd3048f55640cf576bd6b5c3afee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for API errors in APIs that support this Log api error, CHECK_API_ERROR must be defined, otherwise this function has no effect.  <a href="#a4eefd3048f55640cf576bd6b5c3afee8">More...</a><br/></td></tr>
<tr class="separator:a4eefd3048f55640cf576bd6b5c3afee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd4eaf02b79f224b3e925702072f7b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api.html#a6dd4eaf02b79f224b3e925702072f7b3">succeeded</a> (Result::Enum res)</td></tr>
<tr class="memdesc:a6dd4eaf02b79f224b3e925702072f7b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the provided result code is successful, log possible api errors if not.  <a href="#a6dd4eaf02b79f224b3e925702072f7b3">More...</a><br/></td></tr>
<tr class="separator:a6dd4eaf02b79f224b3e925702072f7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main PVRApi Namespace. </p>
<hr/>
 </div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a8795856f3d769f5d37978c59e368f761"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef RefCountedResource&lt;<a class="el" href="classpvr_1_1api_1_1impl_1_1_buffer_gles_impl.html">impl::BufferGlesImpl</a>&gt; <a class="el" href="namespacepvr_1_1api.html#a8795856f3d769f5d37978c59e368f761">pvr::api::BufferGles</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OpenGL ES implementation of the <a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">Buffer</a>. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="a8d935dcf60fe99740c37b6c56d7d7fbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef RefCountedResource&lt;<a class="el" href="structpvr_1_1api_1_1impl_1_1_color_attachment_view_impl.html">impl::ColorAttachmentViewImpl</a>&gt; <a class="el" href="namespacepvr_1_1api.html#a8d935dcf60fe99740c37b6c56d7d7fbd">pvr::api::ColorAttachmentView</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="addcbe955a9af0d9edadc9ad107151699"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef RefCountedResource&lt;<a class="el" href="classpvr_1_1api_1_1impl_1_1_default_fbo_gles_impl.html">impl::DefaultFboGlesImpl</a>&gt; <a class="el" href="namespacepvr_1_1api.html#addcbe955a9af0d9edadc9ad107151699">pvr::api::DefaultFboGles</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0099c6787d2b822573fa8f95c9fc3237"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef RefCountedResource&lt;<a class="el" href="structpvr_1_1api_1_1impl_1_1_depth_stencil_view_impl.html">impl::DepthStencilViewImpl</a>&gt; <a class="el" href="namespacepvr_1_1api.html#a0099c6787d2b822573fa8f95c9fc3237">pvr::api::DepthStencilView</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8382a5c14d65fcf93385d2b4427dc3b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef RefCountedResource&lt;<a class="el" href="classpvr_1_1api_1_1impl_1_1_descriptor_set_gles_impl.html">impl::DescriptorSetGlesImpl</a>&gt; <a class="el" href="namespacepvr_1_1api.html#a8382a5c14d65fcf93385d2b4427dc3b8">pvr::api::DescriptorSetGles</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a279942732d36b5df3cac05bbf791233a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef RefCountedResource&lt;<a class="el" href="classpvr_1_1api_1_1impl_1_1_descriptor_set_layout_gles_impl.html">impl::DescriptorSetLayoutGlesImpl</a>&gt; <a class="el" href="namespacepvr_1_1api.html#a279942732d36b5df3cac05bbf791233a">pvr::api::DescriptorSetLayoutGles</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9698b68c02758e0d33254850c950b768"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classpvr_1_1api_1_1impl_1_1_effect_api_impl.html#a9b208f790e7436cca78907f6b952f998">impl::EffectApiImpl::EffectApi_</a> <a class="el" href="namespacepvr_1_1api.html#a9698b68c02758e0d33254850c950b768">pvr::api::EffectApi</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa13d37decce93d2f89d8c52ff7c7232d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classpvr_1_1api_1_1impl_1_1_fbo_impl.html#a980dc3ed2fd7d85748e2073f4c7a64a0">impl::FboImpl::Fbo_</a> <a class="el" href="namespacepvr_1_1api.html#aa13d37decce93d2f89d8c52ff7c7232d">pvr::api::Fbo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a67c63964ff1d3b4179e038bb9a19f8f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef RefCountedResource&lt;<a class="el" href="classpvr_1_1api_1_1impl_1_1_render_pass_impl.html">impl::RenderPassImpl</a>&gt; <a class="el" href="namespacepvr_1_1api.html#a67c63964ff1d3b4179e038bb9a19f8f8">pvr::api::RenderPass</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acc461c8a49bf816fba2c9e9c127cc914"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef RefCountedResource&lt;<a class="el" href="classpvr_1_1api_1_1impl_1_1_shader_impl.html">impl::ShaderImpl</a>&gt; <a class="el" href="namespacepvr_1_1api.html#acc461c8a49bf816fba2c9e9c127cc914">pvr::api::Shader</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9ddbbabd52684a2d9d4aeabdf126d9d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef RefCountedResource&lt;<a class="el" href="classpvr_1_1api_1_1impl_1_1_shader_gles_impl.html">impl::ShaderGlesImpl</a>&gt; <a class="el" href="namespacepvr_1_1api.html#a9ddbbabd52684a2d9d4aeabdf126d9d8">pvr::api::ShaderGles</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aed7be4927619057cc4c9f136198da2f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef RefCountedResource&lt;<a class="el" href="classpvr_1_1api_1_1impl_1_1_sync_impl.html">impl::SyncImpl</a>&gt; <a class="el" href="namespacepvr_1_1api.html#aed7be4927619057cc4c9f136198da2f5">pvr::api::Sync</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reference-counted handle to a Sync object. Default constructor returns an empty handle that wraps a NULL object. Use the CommandBuffer's insertFenceSync to construct a Sync. As with all reference-counted handles, access with the arrow operator. </p>
<hr/>
 
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a42b0a11877ad1979fc48afaf3fa548cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pvr::api::checkApiError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_api_gles2_8h.html#ac83513893df92266f79a515488701770">string</a> *&#160;</td>
          <td class="paramname"><em>errOutStr</em> = <code>NULL</code>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check and return api error. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errOutStr</td><td>error string to be output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>api error code </dd></dl>

</div>
</div>
<a class="anchor" id="a6795b5b93ca36a985f4053a42654eb90"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::debugLogApiError </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks for API errors if the API supports them. If an error is detected, logs relevant error information. Only works in debug builds, and compiles to a NOP in release builds. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="afb70e692b575d23fd009332d750f1147"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpvr_1_1api_1_1_image_data_format.html">api::ImageDataFormat</a> pvr::api::getDisplayColorFormat </td>
          <td>(</td>
          <td class="paramtype">const system::DisplayAttributes &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the color format from a Displaydisplay's color format. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">attribute</td><td>The DisplayAttributes to query. Normally from shell.getDisplayAttributes() </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>outColorFmt The Color Format that this DisplayAttributes object has </dd></dl>
<dl class="section user"><dt>Description:</dt><dd>This function is usually called on an object found with Shell::getDisplayAttributes(), in order to determine the formats that are necessary for an On Screen FBO. </dd></dl>

</div>
</div>
<a class="anchor" id="ae75df536ab883f7319c54866fd8010b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpvr_1_1api_1_1_image_data_format.html">api::ImageDataFormat</a> pvr::api::getDisplayDepthStencilFormat </td>
          <td>(</td>
          <td class="paramtype">const system::DisplayAttributes &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the depth and/or stencil format from a Displaydisplay's color format. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">attribute</td><td>The DisplayAttributes to query. Normally from shell.getDisplayAttributes() </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>outDepthStencilFmt The DepthStencilFormat that this DisplayAttributes object has </dd></dl>
<dl class="section user"><dt>Description:</dt><dd>This function is usually called on an object found with Shell::getDisplayAttributes(), in order to determine the formats that are necessary for an On Screen FBO. </dd></dl>

</div>
</div>
<a class="anchor" id="a81a8d84c51eee8bb5bf9ee6a6aa361d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_api_gles_ext_8h.html#ae5d8fa23ad07c48bb609509eae494c95">void</a> pvr::api::getDisplayFormat </td>
          <td>(</td>
          <td class="paramtype">const system::DisplayAttributes &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">api::ImageDataFormat *&#160;</td>
          <td class="paramname"><em>outColorFmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">api::ImageDataFormat *&#160;</td>
          <td class="paramname"><em>outDepthStencilFmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the display's color, depth and or stencil format from a DisplayAttributes object. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">attribute</td><td>The DisplayAttributes to query. Normally from shell.getDisplayAttributes() </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outColorFmt</td><td>The Color Format that this DisplayAttributes object has </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outDepthStencilFmt</td><td>The DepthStencilFormat that this DisplayAttributes object has </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Description:</dt><dd>This function is usually called on an object found with Shell::getDisplayAttributes(), in order to determine the formats that are necessary for an On Screen FBO. </dd></dl>

</div>
</div>
<a class="anchor" id="a4eefd3048f55640cf576bd6b5c3afee8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::api::logApiError </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>note</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Logger::Severity&#160;</td>
          <td class="paramname"><em>severity</em> = <code>Logger::Error</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for API errors in APIs that support this Log api error, CHECK_API_ERROR must be defined, otherwise this function has no effect. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">severity</td><td>that the error will be reported with, if an error is found </td></tr>
    <tr><td class="paramname">note</td><td>A c-style string that will be prepended to the error description if an error is found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if an API error has occured, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a6dd4eaf02b79f224b3e925702072f7b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::api::succeeded </td>
          <td>(</td>
          <td class="paramtype">Result::Enum&#160;</td>
          <td class="paramname"><em>res</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the provided result code is successful, log possible api errors if not. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A return code from a function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if res is successful errors. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
